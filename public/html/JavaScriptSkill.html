<div id="variables">
  <h3>變數</h3>
  <ul>
    <li><code>var</code>: <b>函數作用域</b>，允許重複定義，變數提升</li>
    <div class="code-container"><pre><code>/* 使用 var 定義變數 */
var x = 10;</code></pre></div>
    <li><code>let</code>: <b>塊級作用域</b>，不允許重複定義，變數提升但進入「暫時性死區」</li>
    <div class="code-container"><pre><code>/* 使用 let 定義變數 */
let y = 20;</code></pre></div>
    <li><code>const</code>: <b>塊級作用域</b>，定義常數，無法重新賦值</li>
    <div class="code-container"><pre><code>/* 使用 const 定義常數 */
const z = 30;</code></pre></div>
  </ul>
  <table>
    <thead>
      <tr>
        <th>函數作用域</th>
        <th>塊級作用域</th>
    	</tr>
    </thead>
		<tbody>    
			<tr>
				<td>變數在函數內有效，函數外無法訪問</td>
				<td>變數在只特定的代碼塊中有效，即使在同一函數內的其他代碼塊中，也無法訪問</td>
			</tr>
			<tr>
				<td><pre><code>function example() {
	var x =10;      // x只在函數內部可訪問
	console.log(x); // 輸出10
}
console.log(x);     //錯誤: x在函數外部不可訪問</code></pre></td>
				<td>
					代碼塊通常由花括號{}定義
					<pre><code>if (true) {
	let y = 20;     // y在此代碼塊內有效
	console.log(y); // 輸出20
}
console.log(y);     // 錯誤: y在代碼塊不可訪問</code></pre>
				</td>
			</tr>
		</tbody>
	</table>
    <ul><li>提升(Hoisting): 在JavaScript中，不論在函數中的哪一行用<code>var</code>宣告變數，一律視為在函數第一行宣告。<br>例如以下三個例子的寫法等義
    	<div class="code-container"><pre><code>function printName( ) {
	myName = "John";     // 直接使用myName變數
	console.log(myName); 
	var my Name;         
	// 直到第三行才宣告myName變數
}
printName(); //John</code></pre></div>
    	<div class="code-container"><pre><code>function printName( ) {
	myName = "John"; // 直接使用myName變數
	if (false) {
		var myName   
	// 即使把宣告放在不會被執行到的if裡面也是合法的
	}
	console.log(myName);
}
printName(); //John</code></pre></div>    
    	<div class="code-container"><pre><code>function printName( ) {
	var my Name;         
	myName = "John";     
	console.log(myName); 
}
printName(); //John</code></pre></div>
    不論你宣告<code>var</code>變數的位置在哪，宣告的動作一律都會被「抬升」到函式的最頂端，這個特性就叫做hoisting(提升)<br>只有「宣告」這個動作有hoisting(提升)的特性，賦值(把值指定給變數)的動作並不會hoisting。
    <div class="code-container"><pre><code>function printName() {
  console.log(myName);  
// undefined，宣告被抬升，但賦值並沒有被抬升
  var myName = "John";  // 宣告並使用
  console.log(myName);  // John
}
printName();</code></pre></div>
		</li></ul>
</div>

<div id="data-types-overview">
    <h3>資料類型概述</h3>
		<ul>
			<li>數字</li>
			<div class="code-container"><pre><code>let number = 42;</code></pre></div>
			<li>字串</li>
			<div class="code-container"><pre><code>let string = "Hello, World!";</code></pre></div>
			<li>布林值</li>
			<div class="code-container"><pre><code>let boolean = true; </code></pre></div>
			<li>未定義</li>
			<div class="code-container"><pre><code>let undefinedVar; // 宣告但未賦值</code></pre></div>
			<li>空值</li>
			<div class="code-container"><pre><code>let nullVar = null; </code></pre></div>
			<li>符號</li>
			<div class="code-container"><pre><code>let uniqueSymbol = Symbol('uniqueIdentifier'); </code></pre></div>
			<li>陣列</li>
			<div class="code-container"><pre><code>let array = [1, 2, 3];</code></pre></div>
			<li>對象</li>
			<div class="code-container"><pre><code>let object = { name: "Alice", age: 25 };</code></pre></div>
		</ul>
</div>

<div id="functions"> 
	<h3>函數定義</h3>
	<p>使用<code>function</code>來創建函數</p>
	<div class="code-container"><ul>
		<li>定義函數</li>
		<pre><code>function greet(name) {
	return `Hello, ${name}!`;
}</code></pre>
		<li>呼叫函數</li>
<pre><code>console.log(greet("Alice"));</code></pre>
	</ul></div>
</div>

<div id="objects">
	<h3>物件</h3>
	<div class="code-container"><ul>
		<li>建立物件</li>
		<pre><code>let person = {
name: "Alice",
age: 30,
greet: function() {
		return `Hello, my name is ${this.name}.`;
	}	
};</code></pre>	
		<li>存取物件屬性和方法</li>
		<pre><code>console.log(person.name);
console.log(person.greet());</code></pre>
	</ul></div>
</div>

<div id="arrays">
	<h3>陣列</h3>
	<div class="code-container"><ul>
		<li>建立數組</li>
		<pre><code>let fruits = ["apple", "banana", "cherry"];</code></pre>
		<li>存取陣列元素</li>
		<pre><code>console.log(fruits[0]);</code></pre>
		<li>遍歷數組</li>
		<pre><code>fruits.forEach(function(fruit) {
	console.log(fruit);
});</code></pre>
	</ul></div>
</div>

<div id="conditionals">
	<h3>條件語句</h3>
	<div class="code-container"><pre><code>/* if 語句 */
if (x > 10) {
	console.log("x is greater than 10");
} else if (x === 10) {
	console.log("x is 10");
} else {
	console.log("x is less than 10");
}</code></pre></div>
</div>

<div id="loops">
	<h3>迴圈語句</h3>
	<div class="code-container">
		<ul>
			<li><code>for</code> 迴圈</li>
			<pre><code>for (let i = 0; i &lt; 5; i++) {
	console.log(i);
}</code></pre>
			<li><code>while</code> 迴圈</li>
			<pre><code>let count = 0;
while (count &lt; 5) {
console.log(count);
count++;
}</code></pre>
		</ul>	
	</div>
</div>

<div id="events">
	<h3>事件處理</h3>
	<div class="code-container"><pre><code>/* 新增事件監聽器 */
document.getElementById("myButton").addEventListener("click", function() {
	alert("Button clicked!");
});</code></pre></div>
	<ol>
		<li>使用 <code>getElementById</code> 獲取元素:<br>用於從HTML文件獲取具有指定ID的元素。返回一個匹配的元素，如果沒有找到，則返還<code>null</code>。
			<ul>
				<li>語法:
					<pre><code>let element = document.getElementById("elementId");</code></pre>
				</li>
				<li>示範:
					<pre><code>此為html
&lt;button&gt; id="myButton">Click Me&lt;/button&gt;
此為javascript
let button = document.getElementById("myButton")</code></pre>
        </li>
      </ul> 
  	</li>
		
		<li>添加事件監聽器:<br>使用<code>addEventListener</code>方法，可以給獲取到的元素添加事件監聽器。常見的事件包括<code>click</code>、<code>mouseover</code>、<code>keydown</code>等。
			<ul>
				<li>語法:
					<pre><code>此為javaScript
element.addEventListener("event", eventHandler);</code></pre>
				</li>
				<li>示範:
					<pre><code>此為javaScript
button.addEventListener("click", handleClick);</code></pre>
				</li>
			</ul>
		</li>

		<li>事件處理函數:<br>（<code>handleClick</code>、<code>handleMouseOver</code>...等）用於處理觸發的事件。可以定義不同的回調函數來處理不同的事件。
			<ul>
				<li><code>handleMouseOver</code>: 處理滑鼠懸停事件</li>
				<li><code>handleKeyDown</code>: 處理按鈕按下事件</li>
				<li><code>handleFocus</code>: 處理元素獲得焦點事件</li>
			</ul>
			<pre><code>function handleClick(event) {
	// 當按鈕被點擊時顯示提示框
	alert("Button clicked!");
}</code></pre>
		</li>
	</ol>
</div>

<div id="asynchronous">
	<h3>非同步程式設計</h3>
	<div class="code-container"><pre><code>/* 使用 Promise */
function fetchData() {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve("Data fetched");
		}, 2000);
	});
}

fetchData().then(result => {
	console.log(result);
});</code></pre></div>
	<ul><b>Promise</b>
		<li>
			Promise用來處理非同步操作，resolve代表成功，reject代表失敗
			<br>setTimeout中，() =&gt; {}是一個回調函數，它在指定的延遲時間後執行。
			2000是延遲的時間(以毫秒為單位)，也就是2秒
		</li>
		<li>fetchData返回一個Promise對象。</li>
	</ul>
	<div class="code-container"><pre><code>/* 使用 async/await */
async function fetchDataAsync() {
	let result = await fetchData();
	console.log(result);
}

fetchDataAsync();</code></pre></div>
	<ul><b>async/await</b>
		<li>async關鍵字函數返還一個Promise<br>在 async 函數內部，await 關鍵字用於等待 Promise 完成。</li>
	</ul>
</div>

